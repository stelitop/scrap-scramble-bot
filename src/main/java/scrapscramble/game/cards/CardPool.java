package scrapscramble.game.cards;

import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.exception.CloneFailedException;
import org.jetbrains.annotations.Nullable;
import org.reflections.Reflections;
import org.reflections.scanners.Scanners;
import scrapscramble.game.cards.annotations.TokenFromClass;
import scrapscramble.game.cards.annotations.TokenFromMethod;
import scrapscramble.game.cards.annotations.UpgradeFromClass;
import scrapscramble.game.cards.annotations.UpgradeFromMethod;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

/**
 * A card pool contains all of the cards used during a game, both Upgrades that
 * appear in the shop and tokens generated by other cards.
 */
public class CardPool implements Cloneable {

    /**
     * A list of upgrades that contains all upgrades that will be available to
     * the players.
     */
    private List<Upgrade> upgrades;
    // TODO Replace list with a Set for a better performance

    /**
     * A list of all token cards in the game. Those cards are not obtained through
     * the shop but through other cards.
     */
    private List<Card> tokens;

    /**
     * A list of all spare parts that are a part of the game. Spare parts are special
     * tokens generated by the Magnetic keyword.
     */
    private List<SparePart> spareParts;

    /**
     * Default constructor. Creates a card pool that doesn't contain any cards.
     */
    public CardPool() {
        this.upgrades = new ArrayList<>();
        this.tokens = new ArrayList<>();
        this.spareParts = new ArrayList<>();
    }

    /**
     * Collects all upgrades from the code that have been annotated with
     * {@link UpgradeFromClass} or <insert for builder methods>.
     * @param packageName The starting package from which to start searching.
     *                    "scrapscramble" would make it search the whole project
     *                    for classes. "scrapscramble.game.cards.implementations"
     *                    would make it only search in this folder.
     * @throws ClassCastException When one of the annotated classes does not
     * extend {@link Upgrade}.
     * @throws NoSuchMethodException When one of the annotated classes does
     * not have a public empty constructor.
     */
    private void collectAllAnnotatedUpgrades(String packageName) throws ClassCastException, NoSuchMethodException,
            InvocationTargetException, InstantiationException, IllegalAccessException {

        Reflections reflections = new Reflections(packageName, Scanners.MethodsAnnotated, Scanners.TypesAnnotated);

        //adds the annotated classes
        var upgradeClasses = reflections.getTypesAnnotatedWith(UpgradeFromClass.class);
        for (var clazz : upgradeClasses) {
            Class<? extends Upgrade> castedClass = clazz.asSubclass(Upgrade.class);
            //call the empty constructor
            Upgrade u = castedClass.getConstructor().newInstance();
            this.upgrades.add(u);
        }

        //adds the annotated methods
        var upgradeMethods = reflections.getMethodsAnnotatedWith(UpgradeFromMethod.class);
        for (var method : upgradeMethods) {
            Object u = method.invoke(null);
            if (!(u instanceof Upgrade)) throw new ClassCastException();
            this.upgrades.add((Upgrade)u);
        }
    }

    private void collectAllAnnotatedTokens(String packageName) throws
            NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {

        Reflections reflections = new Reflections(packageName, Scanners.MethodsAnnotated, Scanners.TypesAnnotated);
        //adds the annotated classes
        var tokenClasses = reflections.getTypesAnnotatedWith(TokenFromClass.class);
        for (var clazz : tokenClasses) {
            Class<? extends Card> castedClass = clazz.asSubclass(Card.class);
            //call the empty constructor
            Card c = castedClass.getConstructor().newInstance();
            if (c instanceof SparePart sp) this.spareParts.add(sp);
            else this.tokens.add(c);
        }

        //adds the annotated methods
        var tokenMethods = reflections.getMethodsAnnotatedWith(TokenFromMethod.class);
        for (var method : tokenMethods) {
            Object c = method.invoke(null);
            if (!(c instanceof Card)) throw new ClassCastException();
            if (c instanceof SparePart sp) this.spareParts.add(sp);
            else this.tokens.add((Card)c);
        }
    }

    /**
     * Creates a new card pool entirely out of cards that have been "hardcoded" in
     * the code.
     * @return A card pool that contains all upgrades annotated with {@link UpgradeFromClass},
     * {@link UpgradeFromMethod}, <link for tokens>
     * @throws UnableToCreateCardPoolException When a mistake happens when creating the pool,
     * usually from an incorrect annotation.
     */
    public static CardPool fromAnnotations() throws UnableToCreateCardPoolException{
        CardPool pool = new CardPool();
        try {
            pool.collectAllAnnotatedUpgrades("scrapscramble.game.cards.implementations");
            pool.collectAllAnnotatedTokens("scrapscramble.game.cards.implementations");
        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {
            e.printStackTrace();
            throw new UnableToCreateCardPoolException();
        }
        return pool;
    }

    /**
     * Gets a list containing all upgrades.
     * @return A list that contains all upgrades. Changes to this list are not
     * reflected in the card pool, however changes to the cards are.
     */
    public List<Upgrade> getUpgrades() {
        return new ArrayList<>(this.upgrades);
    }

    /**
     * Gets how many Upgrades are in the card pool.
     * @return Amount of upgrades.
     */
    public int totalUpgrades() {
        return this.upgrades.size();
    }

    /**
     * Gets how many tokens are in the card pool.
     * @return Amount of tokens.
     */
    public int totalTokens() {
        return this.tokens.size();
    }

    /**
     * Gets how many spare parts are in the card pool/
     * @return Amount of spare parts.
     */
    public int totalSpareParts() {
        return this.spareParts.size();
    }

    /**
     * Gets a random upgrade across all upgrades in the pool, excluding tokens.
     * @return A deep copy of a random upgrade, or null if the card pool is empty.
     */
    public @Nullable Upgrade randomUpgrade() {
        if (this.upgrades.size() == 0) return null;
        try {
            return this.upgrades.get( RandomUtils.nextInt(0, this.upgrades.size()) ).clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("A problem occurred when cloning the upgrade.");
        }
    }

    /**
     * Gets a random upgrade across all upgrades in the pool, excluding tokens,
     * that fulfils a condition.
     * @param filter Condition the upgrade must match.
     * @return A deep copy of a random upgrade, or null if no such upgrades exist.
     */
    public @Nullable Upgrade randomUpgrade(Predicate<Upgrade> filter) {
        List<Upgrade> cands = this.upgrades.stream().filter(filter).toList();
        if (cands.size() == 0) return null;
        try {
            return cands.get( RandomUtils.nextInt(0, cands.size()) ).clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            throw new RuntimeException("A problem occurred when cloning the upgrade.");
        }
    }

    /**
     * Gets a list of X random upgrades across all upgrades in the pool, excluding
     * tokens, that fulfil a condition. There can be duplicates across those
     * upgrades.
     * @param amount How many upgrades to get.
     * @param filter Condition the upgrades must match.
     * @return A list of upgrades, or null if there are no upgrades that match the condition.
     */
    public @Nullable List<Upgrade> randomUpgrades(int amount, Predicate<Upgrade> filter) {
        List<Upgrade> ret = new ArrayList<>();
        for (int i = 0; i < amount; i++) {
            Upgrade u = this.randomUpgrade(filter);
            if (u == null) return null;
            ret.add(u);
        }
        return ret;
    }

    /**
     * Gets a card from the card pool by the given name. Used when needed to
     * get a fresh copy of an upgrade, instead of through a constructor. This
     * will search for an upgrade of the same name. If none match, then it will
     * check for tokens and spare parts.
     * @param cardName The name of the card to look for.
     * @return A card with the same name, or null if no such card exists in the
     * pool.
     */
    public @Nullable Card get(String cardName) {
        try {
            Optional<Upgrade> u = this.upgrades.stream().filter(x -> x.name.equals(cardName)).findFirst();
            if (u.isPresent()) return u.get().clone();
            Optional<Card> t = this.tokens.stream().filter(x -> x.name.equals(cardName)).findFirst();
            if (t.isPresent()) return t.get().clone();
            Optional<SparePart> sp = this.spareParts    .stream().filter(x -> x.name.equals(cardName)).findFirst();
            if (sp.isPresent()) return sp.get().clone();
            return null;
        } catch (CloneNotSupportedException e) {
            throw new CloneFailedException("Could not clone an upgrade.");
        }
    }

    @Override
    public CardPool clone() throws CloneNotSupportedException {
        CardPool copy = new CardPool();
        for (var u : this.upgrades) copy.upgrades.add(u.clone());
        for (var c : this.tokens) copy.tokens.add(c.clone());
        for (var sp : this.spareParts) copy.spareParts.add(sp.clone());
        return copy;
    }
}
